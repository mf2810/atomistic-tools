import numpy as np
#from matplotlib import pyplot as plt

'''
This is a code that takes some of your  atomistic simulation snapshots (frames/*.gro), 
looks  up  in  polyIndex  which  atomistic  molecules  correspond  to  a  CG bead, and
calculates the CG  centre  of mass of the CG bead and outputs it to frames2/*.gro.

This can be used to calculate angular distributions or bond distance distributions.

You have to specify how many CG segments exist in each molecule in nMono, and also how 
many atomistic frames you want to generate.
'''

numframe = 499
numMono  = 6
listPairs = np.loadtxt('polyIndex')

##############################################

class Pairs:
    def __init__(self,filename,pair):
	self.pair = pair
	self.posit = []
	framefile = open(filename, 'r')
	lineList = framefile.readlines()
	self.boxDim = lineList[len(lineList)-1].split()
	self.boxDim = float(self.boxDim[0])

 	framefile.seek(0)
	framefile.readline()
	framefile.readline()
	maxPair = 0
	for i in pair:
	    if int(i) > maxPair:
		maxPair = int(i)

 	for i in range(0, maxPair):
	    line = framefile.readline()
	    words = line.split()
	    #print words
	    if len(words) == 9:
	        if int(words[2]) in pair:
		    self.posit.append([float(words[3]), float(words[4]), float(words[5])])
	    elif len(words) == 8:
		if len(words[1]) == 7:
		    tempVal = words[1][(len(words)-6):]
	            if int(tempVal) in pair:
		        self.posit.append([float(words[2]), float(words[3]), float(words[4])])
		elif len(words[1]) == 8:
		    tempVal = words[1][(len(words)-5):]
	            if int(tempVal) in pair:
		        self.posit.append([float(words[2]), float(words[3]), float(words[4])])
		

	framefile.close()	
	#print self.pair
	#print self.posit

	for j in range(0, len(self.posit)):
	    for i in range(0, len(self.posit[j])):
	        if self.posit[j][i] - self.posit[0][i] < -1*self.boxDim/2:
	    	    self.posit[j][i] = self.posit[j][i] + self.boxDim
	        elif self.posit[j][i] - self.posit[0][i] > self.boxDim/2:
	    	    self.posit[j][i] = self.posit[j][i] - self.boxDim

	cascade = np.array([])
	for i in range(0, len(self.posit)):
	    if i == 0:
		cascade = np.array(self.posit[i])
	    else:
		cascade = cascade + np.array(self.posit[i])
	self.positAv = cascade/len(pair)
	#print self.posit
	#print 'dist = ', dist(self.posit[0], self.posit[1])
	self.dist = dist(self.posit[0], self.posit[1])
	#print self.positAv
	#print '\n\n'


def dist(vec1, vec2):
    dist = 0
    for i in range(0, len(vec1)):
	dist = dist + (vec1[i]-vec2[i])**2
    return dist**.5





############################################
	    

for i in range(0,int(numframe)):
        filename = "frames/%d.gro" % i
        filename2 = "frames2/%d.gro" % i
	inFile 	 = open("frames/%d.gro" % i, 'r')
	outFile  =  open("frames2/%d.gro" % i, 'w')
	outFile.write('Generated by trjconv : MAZCHAIN Pv at 617K t= %11.5f\n %i\n' % (i, len(listPairs)))
	linez = inFile.readlines()
	linez = linez[len(linez)-1]
	pairList = np.ndarray.tolist(np.copy(listPairs))
	molNum = 0
	for j in range(0, len(pairList)):
	    pairList[j] = Pairs(filename, pairList[j])
	    if j%numMono == 0:
		molNum = molNum + 1 

	    outFile.write('%5d%-5s%5s%5d%8.3f%8.3f%8.3f' %(molNum,'PLE','PL',(j+1),pairList[j].positAv[0],pairList[j].positAv[1],pairList[j].positAv[2]))
	    outFile.write('\n')
	outFile.write(linez)
	print i+1, 'done'
	inFile.close()
	outFile.close()
	    
#plt.hist(distr, bins=np.arange(min(distr), max(distr) + (max(distr) - min(distr))/20, (max(distr) - min(distr))/20))
#plt.show()

